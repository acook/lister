require "yaml"

module Themer
  class Theme
    property colormap = Hash(String, Colorset).new
    property reset : Colorset = Colorset.new style: "normal"
    property default : Colorset | Nil

    SKIP = Colorset.new

    def self.load(filename)
      yaml = Hash(String, Hash(String, StrNil | StrNil | StrNil)).new

      File.open filename do |file|
        yaml = YAML.parse(file).as_h
      rescue ex : YAML::ParseException
        Themer.warn "Encountered an error in your theme file:"
        Themer.warn "\t#{ex.message}"
        return nil
      end

      per_def = nil
      data = Hash(String, Colorset).new
      yaml.each do |k, v|
        colors = Colorset.new \
            style: v["style"]?.to_s, fg: v["fg"]?.to_s, bg: v["bg"]?.to_s,
            style16: v["style16"]?.to_s, fg16: v["fg16"]?.to_s, bg16: v["bg16"]?.to_s,
            style256: v["style256"]?.to_s, fg256: v["fg256"]?.to_s, bg256: v["bg256"]?.to_s

        if k.to_s == "DEFAULT"
          per_def = colors
        else
          data[k.to_s] = colors
        end
      end

      self.new.tap do |t|
        t.default = per_def if per_def
        t.colormap = data
      end
    end

    def save(filename)
      per_def = @default
      per = colormap.dup
      per = {"DEFAULT" => per_def}.merge(per) if per_def # merge so DEFAULT is first entry
      File.open filename, mode: "w" do |file|
        file.puts YAML.dump per
      end
    end

    def for(id : String) : Colorset
      colormap[id]? || default || raise ArgumentError.new "#{self.class}#for(String) color id not found #{id.inspect}"
    end

    def for(ids : Array(String)) : Colorset
      found = nil
      ids.find do |id|
        found = fetch id
      end

      found || default || raise ArgumentError.new("#{self.class}#for(Array) no match found for color ids #{ids.inspect}")
    end

    # the start of a new category of methods which will handle more use cases I've discovered
    # #all(ids)    -> returns all matching colors from the input list
    # #first(ids)  -> returns the first non-empty color from the input list or raises an error
    # #first?(ids) -> returns the first non-empty color from the input list or nil
    # #sum(ids)    -> returns a Color generated by combining all colors from the list, first takes precedence
    def all(ids : Array(String)) : Array(Colorset)
      ids.each_with_object(Array(Color).new) do |id, acc|
        color = fetch id
        acc << color if color
      end
    end

    def fetch(id : String) : Colorset | Nil
      id == "skip" ? SKIP : colormap.fetch id, nil
    end

    def [](id : String) : Colorset
      colormap[id]
    end

    def []=(id : String, color : Colorset)
      colormap[id] = color || raise ArgumentError.new("key cannot be nil")
    end

    def ==(other : self)
      default == other.default && colormap == other.colormap
    end
  end
end
